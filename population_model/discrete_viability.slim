// Author: Sam Champer and Isabel Kim.
// Created in association with Jackson Champer and the Messer lab.

// A framework for simulating many different gene drives
// with varying parameters, intended to be configured by
// alterning the heading below, or by dynamically varying
// values in the header using an associated Python file.

//These gene drives are located on the same chromosome as their target sites.
//This landscape is simulated in 2 dimensions.

// The following header to be replaced via python,
// such that these values can be varied across multiple runs of slim.

initialize() {
	defineCfgParam("OUTPUT_SPATIAL_DATA", F);
	defineCfgParam("OUTPUT_FILE","viability_movie");
	defineCfgParam("test_genetic_load",0.0);

	defineCfgParam("DRIVE_CONVERSION", 0.9);///germline_resistance cut rate is for homing drive and resistance rate is for TADS drive
	defineCfgParam("GERMLINE_RESISTANCE_CUT_RATE_F", 0.0); //germline_resistance cut rate is for homing drive
	defineCfgParam("GERMLINE_RESISTANCE_CUT_RATE_M", 0.0);
	defineCfgParam("HOMING_PHASE_CUT_RATE_F", DRIVE_CONVERSION);
	defineCfgParam("HOMING_PHASE_CUT_RATE_M", DRIVE_CONVERSION);
	defineCfgParam("WHOLE_GERMLINE_RESISTANCE_CUT_RATE",(1-DRIVE_CONVERSION)/2);
    defineCfgParam("LATE_GERMLINE_RESISTANCE_CUT_RATE_F", WHOLE_GERMLINE_RESISTANCE_CUT_RATE/(1-DRIVE_CONVERSION));
	defineCfgParam("LATE_GERMLINE_RESISTANCE_CUT_RATE_M", LATE_GERMLINE_RESISTANCE_CUT_RATE_F);
	if(exists("EMBRYO_RESISTANCE_CUT_RATE_F_INPUT"))
        defineConstant("EMBRYO_RESISTANCE_CUT_RATE_F", 1-(1-EMBRYO_RESISTANCE_CUT_RATE_F_INPUT)^(1/1.83));  //0.02764 calculated by 1-pow(0.95,1/1.83)
    else
        defineConstant("EMBRYO_RESISTANCE_CUT_RATE_F",0.05595); //default 0.1
	defineCfgParam("EMBRYO_RESISTANCE_CUT_RATE_M", 0.0);
	defineCfgParam("SOMATIC_FITNESS_MULTIPLIER_F", 0.95); //for dr-wt individuals, mean the percent of fertile offsprings
	defineCfgParam("SOMATIC_FITNESS_MULTIPLIER_M", 1.0);
	defineCfgParam("HET_MOTHER_CAS_INHERITANCE", 1.83);   // when the mother is dr-wt and drive conversion happens, the amount of cas9 in it.
	defineCfgParam("X_SHRED_RATE", 0.0);
	defineCfgParam("GROWTH_AT_ZERO_DENSITY", 6.0); // beta=6.0 if not defined at command line
	defineCfgParam("AVERAGE_DISTANCE",0.05);
	defineCfgParam("MAX_ATTEMPTS_TO_FIND_SUITABLE_MATE",20);  ///?
	defineCfgParam("MAX_OFFSPRINGS_PER_FEMALE",50);

	defineConstant("TWO_DIMENSIONAL", F); //if F, simulated in 1D
	defineConstant("HOMING_DRIVE", T);

	//suppression drives
	defineConstant("RECESSIVE_FEMALE_STERILE_SUPPRESSION_DRIVE", T);
	defineConstant("RECESSIVE_MALE_STERILE_SUPPRESSION_DRIVE", F);
	defineConstant("RECESSIVE_BOTH_SEX_LETHAL_SUPPRESSION_DRIVE", F);
	defineConstant("TADE_SUPPRESSION", F);
	defineConstant("TADS_AUTOSOMAL_SUPPRESSION", F);
	defineConstant("TRACK_BY_CELL", T); //for chase detection in suppression drives
	defineConstant("SUPPRESSION_OUTPUT", RECESSIVE_FEMALE_STERILE_SUPPRESSION_DRIVE | RECESSIVE_MALE_STERILE_SUPPRESSION_DRIVE | RECESSIVE_BOTH_SEX_LETHAL_SUPPRESSION_DRIVE | TADE_SUPPRESSION | TADS_AUTOSOMAL_SUPPRESSION);

	//modification drives
	defineConstant("TADE", F);
	defineConstant("TADE_DOUBLE_RESCUE", F);
	defineConstant("TADS_MODIFICATION", F);
	defineConstant("TARE", F);
	defineConstant("X_LINKED_DRIVE", F);

	//drive parameters
	defineConstant("DRIVE_FITNESS_VALUE", 1.0);
	defineConstant("GERMLINE_RESISTANCE_RATE", 0.08); //resistance rate is for TADS drive
	defineConstant("NUM_GRNAS", 1);
	defineConstant("R1_OCCURRENCE_RATE", 0.0);

	//ecology parameters
	defineConstant("INBREEDING_AVOIDANCE_FACTOR", 0.0); //if negative, % inc. if positive, % dec.
	defineConstant("INBREEDING_FECUNDITY_PENALTY", 0.0); //from 0 - 1, always % dec.
	defineConstant("REPRISING_BOUNDARIES", T); //toroidal if false
	defineCfgParam("SIM_BOUND",3); // the side length of the simulation area
	defineCfgParam("EFFECTIVE_POPULATION_DENSITY",10000);
	catn("SIM BOUND: "+asString(SIM_BOUND));

	//release specifics
	defineConstant("HETEROZYGOUS_DROP", T);
	defineConstant("DROP_RADIUS", 0.01);
	defineConstant("NO_DROP", T);
	defineConstant("CIRCLE_DROP", T);
	defineConstant("LEFT_EDGE_DROP", F);
	defineConstant("UNIFORM_DROP", F);
	defineConstant("CORNER_DROP",F); //can use with torodial boundaries
	defineConstant("WT_START",T);
	defineConstant("RELEASE_INTERVAL", 1000); // 1000 means only 1 release
	defineGlobal("chasing_cells",c());

	//2D parameters
	if (TWO_DIMENSIONAL) {
		defineCfgParam("CAPACITY", asInteger(EFFECTIVE_POPULATION_DENSITY*SIM_BOUND^2));
		defineCfgParam("SPEED", AVERAGE_DISTANCE*sqrt(2/PI)); // speed=6.0 if not defined at command line (keep TWO_DIMENSIONAL=T)
		defineCfgParam("DENSITY_INTERACTION_DISTANCE", 0.01);
		defineConstant("DROP_SIZE", asInteger(CAPACITY*0.1));
		defineConstant("NUMBER_OF_CELLS", asInteger(round(SIM_BOUND/AVERAGE_DISTANCE)^2)); //cells number for chasing start detection 1/
		defineConstant("EXPECTED_COMPETITION", MAX_OFFSPRINGS_PER_FEMALE/2 * CAPACITY * PI * DENSITY_INTERACTION_DISTANCE^2/SIM_BOUND^2);
	//1D parameters
	} else {
		defineCfgParam("CAPACITY", asInteger(EFFECTIVE_POPULATION_DENSITY*SIM_BOUND));
		defineCfgParam("DENSITY_INTERACTION_DISTANCE", 0.002);
		defineConstant("DROP_SIZE", 40);
		defineCfgParam("SPEED", AVERAGE_DISTANCE*sqrt(PI/2));
		defineConstant("NUMBER_OF_CELLS", 300);//asInteger(round(SIM_BOUND/AVERAGE_DISTANCE)));
		defineConstant("EQUILIBRIUM_BIN_POPULATION", 0.5*CAPACITY/20);
		defineConstant("EXPECTED_COMPETITION", MAX_OFFSPRINGS_PER_FEMALE/2 * CAPACITY * 2*DENSITY_INTERACTION_DISTANCE/SIM_BOUND);
	}


	// Below are defaults that will not change / are rarely used
	defineConstant("BASELINE_HOMING_SUCCESS_RATE", 1.0);
	defineConstant("EQUILIBRIUM_WT_ALLELE_THRESHOLD", 0.8*2*CAPACITY);
	defineConstant("FEMALE_SPEED", SPEED);
	defineConstant("GENE_UTILITY_TRANSFORMATION_DRIVE", F);
	defineConstant("GENE_UTILITY_TRANSFORMATION_FITNESS", 0.95);
	defineConstant("GRNA_SATURATION_SIMULATED", F);
	defineConstant("HOMING_EDGE_EFFECT", 0.1);
	defineConstant("MATING_DISTANCE", AVERAGE_DISTANCE);
	defineConstant("MALE_ONLY_PROMOTER", F);
	defineConstant("MALE_MATE_CAP", F);
	defineConstant("MAX_MALE_MATINGS", 50);
	defineConstant("NUM_CUT_PHASES", 1);
	defineConstant("R2_FITNESS_VALUE", 1.0);
	defineConstant("HAPLOLETHAL", F);
	defineConstant("HAPLOSUFFICIENT", F);
	defineConstant("MALE_ONLY_DROP", F);
	defineConstant("FEMALE_ONLY_DROP", F);

	// for chasing start detection
	defineGlobal("cell_pop_size",-1); //the pop size in all cells of five generations before
	for (i in 2:(NUMBER_OF_CELLS*6)){
		defineGlobal("cell_pop_size",c(cell_pop_size,-1));
	}
	defineGlobal("time_pop_size",c(-1,-1,-1,-1,-1,-1)); // the whole pop size in five generations before

	// For mortality rate as a function of age:
	// Some females are allowed to survive two generations:
	defineConstant("RATE_FEMALES_SURVIVE", 0.0);

	// This simulation will use a non-Wright-Fisher model.
	initializeSLiMModelType("nonWF");

	// This simulation will take place accross continuous space.
	// By default, model occurs in a torroidal space to prevent edge effects.
	// The model tracks pedigrees in order to implement inbreeding avoidance.

	if (TWO_DIMENSIONAL) {

		if (REPRISING_BOUNDARIES)
			initializeSLiMOptions(keepPedigrees = T, dimensionality = "xy");
		else
			initializeSLiMOptions(keepPedigrees=T, dimensionality="xy", periodicity="xy");

		// Mate searching:
		initializeInteractionType(1, "xy", reciprocal=T, maxDistance=MATING_DISTANCE);
		// Adult competition:
		initializeInteractionType(2, "xy", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
		// for nni
		initializeInteractionType(3, "xy", reciprocal=T, maxDistance=sqrt(2)*SIM_BOUND);
	} else {

		if (REPRISING_BOUNDARIES)
			initializeSLiMOptions(keepPedigrees = T, dimensionality = "x"); //for 1-D
		else
			initializeSLiMOptions(keepPedigrees=T, dimensionality="x", periodicity="x");

		initializeInteractionType(1, "x", reciprocal=T, maxDistance=MATING_DISTANCE);
		initializeInteractionType(2, "x", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
		// for nni
		initializeInteractionType(3, "x", reciprocal=T, maxDistance=SIM_BOUND);
	}

	// Four variations: Wild type, drive, r1 resistance, r2 resistance.
	wt = initializeMutationType("m1", 0.5, "f", 0.0);
	dr = initializeMutationType("m2", 0.5, "f", 0.0);
	r1 = initializeMutationType("m3", 0.5, "f", 0.0);
	r2 = initializeMutationType("m4", 0.5, "f", 0.0);
	cut = initializeMutationType("m5", 0.5, "f", 0.0);
	gap = initializeMutationType("m6", 0.5, "f", 0.0);

	variations = c(wt, dr, r1, r2, cut, gap);

	// Variations are all part of g1 genome element.
	initializeGenomicElementType("g1", variations, c(1, 1, 1, 1, 1, 1));

	// Element is NUM_GRNAS long, each spot on the element representing a GRNA target location.
	initializeGenomicElement(g1, 0, NUM_GRNAS - 1);

	// These mutations overwrite one another.
	variations.mutationStackPolicy = "l";
	variations.mutationStackGroup = 1;

	// No mutation in this model.
	initializeMutationRate(0.0);
	initializeRecombinationRate(0.0);

	// Simulate sexual reproduction: A for autosome.
	initializeSex("A");

	// For now, just modeling interaction with flat strength of 1.
	// i2.setInteractionFunction("n", 1.0, DENSITY_INTERACTION_DISTANCE);
}

//// HELPER FUNC FOR CONSTANTS THAT MAY ASLO BE CONFIGURED VIA COMMAND LINE.
function (void) defineCfgParam(string$ name, lifs value) {
    if (!exists(name))
        defineConstant(name, value);
}

//// FUNCTION FOR EVALUATING POPULATION SUPPRESSION WITH RECESSIVE FEMALE or MALE STERILITY STYLE SUPPRESSION.
function (logical)isRecessiveSterilitySuppressed(o<Individual>$ ind) {
	// Check both chromosomes for drive and type 2 resistance allele. These are the only variants that affect suppression.

	// Individual cannot reproduce if both chromosomes have either a drive or an r2.
	if ((ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS | ind.genome1.countOfMutationsOfType(m4) > 0) & (ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS| ind.genome2.countOfMutationsOfType(m4) > 0))
		return T;
	return F;
}

//// FUNCTION FOR EVALUATING POPULATION SUPPRESSION WITH HAPLOLETHAL STYLE SUPPRESSION.
function (logical)isHLSuppressed(o<Individual>$ ind) {
	// Check both chromosomes for the drive.
	// Individual cannot reproduce if both chromosomes have a drive.
	if (sum(ind.genomes.countOfMutationsOfType(m2)==NUM_GRNAS)==2)
		return T;
	return F;
}

//// HELPER FUNCTION FOR FORMING A RESISTANCE ALLELE AT A GIVEN LOCUS.
function (void)addResistanceAllele(o<Genome>$ genome, i$ locus) {
	// Resistance alleles form at a specified rate.	m3 is r1, m4 is r2.
	genome.addNewDrawnMutation(ifelse((runif(1) < R1_OCCURRENCE_RATE), m3,m4), locus);
}

//// FUNCTION FOR CAS9 EFFECTS IN THE GERMLINE.
function (void)germline(o<Genome>$ child_chromosome, o<Individual>$ parent, f$ resistance_rate) {
	// Determine presence of drive in this parent.
	parent_drive_count = sum(parent.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	// If parent doesn't have drive allele, nothing happens in germline.
	if (!parent_drive_count)
		return;

	// Chromosome must have wt to cut, or nothing happens.
	if (child_chromosome.countOfMutationsOfType(m1)==0)
		return;

	// Using the resistance rate passed to the function,
	// determine the per phase cut rate.
	grna_factor = 1;
	if (GRNA_SATURATION_SIMULATED)
		grna_factor = NUM_GRNAS;
	per_phase_cut_rate = 1 - (1 - resistance_rate)^(1 / (NUM_CUT_PHASES * grna_factor));

	// Determine if cas9 cuts the chromosome in the germline.
	casCut(child_chromosome, per_phase_cut_rate);
}

//// FUNCTION FOR CAS9 EFFECTS IN EMBRYO.
function (void)embryo(o<Genome>$ child_chromosome_1, o<Genome>$ child_chromosome_2, o<Individual>$ mother, f$ resistance_rate) {
	// Determine presence of drive in this mother.
	mother_drive_count = sum(mother.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	// If mother doesn't have drive allele, nothing happens in embryo.
	if (!mother_drive_count)
		return;

	// Determine the per phase cut rate.
	if (HOMING_DRIVE & sum(mother.genomes.countOfMutationsOfType(m1) == NUM_GRNAS) == 1)
		// Special case for homing drive individual that is dr/wt based on experimental data.
		mother_drive_count = HET_MOTHER_CAS_INHERITANCE;
	grna_factor = 1;
	if (GRNA_SATURATION_SIMULATED)
		grna_factor = NUM_GRNAS;
	per_phase_cut_rate = 1 - (1 - resistance_rate)^(mother_drive_count / (NUM_CUT_PHASES * grna_factor));

	// Then pass this rate as an argument to  the casCut funtion to
	// determine if cas9 cuts in the embryo for each chromosome.
	casCut(child_chromosome_1, per_phase_cut_rate);
	casCut(child_chromosome_2, per_phase_cut_rate);
}

//// FUNCTION FOR CAS9 EFFECTS IN EMBRYO.
function (void)male_deposition(o<Genome>$ child_chromosome_1, o<Genome>$ child_chromosome_2, o<Individual>$ father, f$ resistance_rate) {
    // If father doesn't have drive allele, no paternal deposition happens.
    if (!sum(father.genomes.countOfMutationsOfType(m2)))
        return;

    // Established: father had drive and child is female.
    if (child_chromosome_1.countOfMutationsOfType(m2) | child_chromosome_2.countOfMutationsOfType(m2)) {
        if (child_chromosome_1.countOfMutationsOfType(m1) | child_chromosome_2.countOfMutationsOfType(m1)) {
        // Child is D/+
            if (runif(1) < resistance_rate) {
                for (i in seqLen(NUM_GRNAS)) {
                    // Convert the child to D/R2.
                    child_chromosome_1.addNewDrawnMutation(m4, i);
                    child_chromosome_2.addNewDrawnMutation(m2, i);
                }
            }
        }
    }
}

//// FUNCTION FOR CAS9 CUTTING A TARGET CHROMOSOME.
function (void)casCut(o<Genome>$ chromosome, f$ per_phase_cut_rate) {
	// If chromosome has no wild type targets to cut, cas9 does nothing.
	if (chromosome.countOfMutationsOfType(m1)==0)
		return;

	// Vector of possible loci for cas9 to cut:
	wt_loci = chromosome.positionsOfMutationsOfType(m1);

	// In each cut phase...
	for (i in seqLen(NUM_CUT_PHASES)) {
		// At each possible locus...
		for (j in seqAlong(wt_loci)) {
			// Check to see if cas9 cuts...
			if (runif(1) < per_phase_cut_rate) {
				// Convert the locus temporarily to an m5,
				// representing that this site is being cut.
				chromosome.addNewDrawnMutation(m5, wt_loci[j]);
			}
		}
		// If any cuts were made...
		if (chromosome.countOfMutationsOfType(m5)) {
			cut_loci = chromosome.positionsOfMutationsOfType(m5);
			// If just one cut is made, create an R1 or R2 resistance allele.
			if (chromosome.countOfMutationsOfType(m5) == 1)
				addResistanceAllele(chromosome, cut_loci[0]);
			else {
				// If multiple cuts are made in the same cut phase, loss of
				// function results. Convert leftmost site to m4 (R2)
				// everything else through the rightmost site to m6 (cut).
				number_of_cuts = cut_loci[size(cut_loci) - 1] - cut_loci[0];
				for (index in seqLen(number_of_cuts))
					chromosome.addNewDrawnMutation(m6, cut_loci[0] + index + 1);
				chromosome.addNewDrawnMutation(m4, cut_loci[0]);
			}
			// Because some wt loci may have been cut out of the
			// chromosome, remake the vector of possible cut sites.
			if (chromosome.countOfMutationsOfType(m1) == 0)
				return;
			wt_loci = chromosome.positionsOfMutationsOfType(m1);
		}
	}
}


//// FUNCTION FOR SIMULATING HOMING THAT OCCURS DURING HOMOLOGY DIRECTED REPAIR.
function (void)hdr(o<Genome>$ chromosome, o<Individual>$ parent, f$ cut_rate) {
	// Determine presence of drive in this parent. If parent doesn't have drive allele, nothing happens in germline.
	if (parent.countOfMutationsOfType(m2)==0)
		return;

	// If chromosome has no wild type targets to cut, cas9 does nothing.
	if (chromosome.countOfMutationsOfType(m1)==0)
		return;

	// Rate of cutting occurs at the HOMING_PHASE_CUT_RATE, modified by gRNA saturation, if toggled on.
	if (GRNA_SATURATION_SIMULATED)
		cut_rate = 1 - (1 - cut_rate)^(1/NUM_GRNAS);

	// Vector of possible loci.
	wt_loci = chromosome.positionsOfMutationsOfType(m1);

	// At each possible locus...
	for (i in seqAlong(wt_loci))
		// Check to see if cas9 cuts...
		if (runif(1) < cut_rate)
			// Convert the locus temporarily to an m5,
			// representing that this site is being cut.
			chromosome.addNewDrawnMutation(m5, wt_loci[i]);

	// If any cuts were made...
	if (chromosome.countOfMutationsOfType(m5)) {
		// Determine how extreme the cuts are relative to the target package (the drive).
		cut_loci = chromosome.positionsOfMutationsOfType(m5);
		leftmost_cut_index = cut_loci[0];
		rightmost_cut_index = cut_loci[size(cut_loci) - 1];
		// Sections that have already been cut out of the chromosome
		// also contribute to the size of the cut section.
		missing_loci = chromosome.positionsOfMutationsOfType(m6);
		// Adjusted indecies are amounts by which the cut ends differ
		// from the perfect cut that spans the entire target area.
		adjusted_left_index = leftmost_cut_index - sum(missing_loci < leftmost_cut_index);
		rightmost_cut_index = rightmost_cut_index + sum(missing_loci > rightmost_cut_index);
		adjusted_right_index = NUM_GRNAS - 1 - rightmost_cut_index;

		successful_homing_rate = BASELINE_HOMING_SUCCESS_RATE * (1 - HOMING_EDGE_EFFECT * adjusted_left_index) * (1 - HOMING_EDGE_EFFECT * adjusted_right_index);

		// Check to see if homing succeeds.
		if (runif(1) < successful_homing_rate)
			for (i in seqLen(NUM_GRNAS))
				chromosome.addNewDrawnMutation(m2, i);
		else {
			// A small percentage of individuals have complete failures of the homing drive,
			// resulting in the entire section of the chromosome becoming a resistance allele.
			total_failure_avoidance_rate = 0.9 * (1 - 0.1 * adjusted_left_index) * (1 - 0.1 * adjusted_right_index);

			if (runif(1) < total_failure_avoidance_rate) {
				// Some catastrophic failures become all R1, at the following rate:
				total_r1_rate = 0.001 * (1 + adjusted_right_index - adjusted_left_index);
				// All-R1 catastrophic failures occur only in HAPLOSUFFICIENT or HAPLOSLETHAL drives.
				if (runif(1) < total_r1_rate & (HAPLOLETHAL | HAPLOSUFFICIENT))
					for (i in seqLen(NUM_GRNAS))
						chromosome.addNewDrawnMutation(m3, i);
				else
					for (i in seqLen(NUM_GRNAS))
						chromosome.addNewDrawnMutation(m4, i);
			}
			// If neither homing nor a catastrophic failure occur, normal repair happens.
			else {
				// If just one cut was made, create an R1 or R2 resistance allele.
				if (chromosome.countOfMutationsOfType(m5) == 1)
					addResistanceAllele(chromosome, cut_loci[0]);
				else {
					// If mutlple cuts were made, leftmost site to m4 (R2),
					// everthing else through the rightmost site to m6 (cut).
					number_of_cuts = cut_loci[size(cut_loci) - 1] - cut_loci[0];
					for (index in seqLen(number_of_cuts))
						chromosome.addNewDrawnMutation(m6, cut_loci[0] + index + 1);
					chromosome.addNewDrawnMutation(m4, cut_loci[0]);
				}
			}
		}
	}
}

//// HELPER FUNCTION TO OVERWRITE ONE GENOME WITH ANOTHER.
function (void)copy_genome(o<Genome>$ source, o<Genome>$ destination) {
	for (i in seqAlong(source.positionsOfMutationsOfType(m1))) //m1 loci (wt)
		destination.addNewDrawnMutation(m1, source.positionsOfMutationsOfType(m1)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m2))) //m2 loci (dr)
		destination.addNewDrawnMutation(m2, source.positionsOfMutationsOfType(m2)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m3))) //m3 loci (r1)
		destination.addNewDrawnMutation(m3, source.positionsOfMutationsOfType(m3)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m4))) //m4 loci (r2)
		destination.addNewDrawnMutation(m4, source.positionsOfMutationsOfType(m4)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m5))) //m5 loci (cut)
		destination.addNewDrawnMutation(m5, source.positionsOfMutationsOfType(m5)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m6))) //m6 loci (gap)
		destination.addNewDrawnMutation(m6, source.positionsOfMutationsOfType(m6)[i]);
}

//// RULES FOR FITNESS BASED ON GENOTYPE.
function (f$)genotypeFitness(o<Individual>$ ind) {
	// If the drive is one that targets a gene function, two copies of either the gene or r2 incur an associated fitness cost.
	if (GENE_UTILITY_TRANSFORMATION_DRIVE) {
		if ((ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS | ind.genome1.countOfMutationsOfType(m4) > 0) & (ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS | ind.genome2.countOfMutationsOfType(m4) > 0))
			return GENE_UTILITY_TRANSFORMATION_FITNESS;
		return 1.0;
	}
	// Representation of the value of the two chromosomes.
    dr_1 = ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS;
    dr_2 = ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS;
    wt_1 = ind.genome1.countOfMutationsOfType(m1) > 0;
    wt_2 = ind.genome2.countOfMutationsOfType(m1) > 0;

	c1_value = ifelse(dr_1, DRIVE_FITNESS_VALUE, 1.0);
	c2_value = ifelse(dr_2, DRIVE_FITNESS_VALUE, 1.0);

	// Check both chromosomes for resistance allele.
	// If R2_FITNESS_VALUE is lower than 1.0, r2 mutations lower fitness.
	if (ind.genome1.countOfMutationsOfType(m4) > 0)
		c1_value = c1_value * R2_FITNESS_VALUE;
	if (ind.genome2.countOfMutationsOfType(m4) > 0)
		c2_value = c2_value * R2_FITNESS_VALUE;

	somatic_fitness_mult = 1;
	if ((dr_1 & wt_2) | (dr_2 & wt_1))
		if (ind.sex == "F")
			somatic_fitness_mult = SOMATIC_FITNESS_MULTIPLIER_F;

	// Return fitness for individual with this genotype.
	return sqrt(c1_value * c2_value) * somatic_fitness_mult;
}


//// REPRODUCTION RULES FOR EACH FEMALE.
reproduction(NULL, "F") {
	//allow 10 generations for the population to get equilibrium
	if(asInteger(sim.cycle)>10){
		if(runif(1)<test_genetic_load)
			return;
	}
	
	// First, evaluate whether reproduction is suppressed by a population suppression drive,
	// Then, select a mate based on fitness, then generate offspring.

	// Suppression drives:
	if (RECESSIVE_FEMALE_STERILE_SUPPRESSION_DRIVE)
		if (isRecessiveSterilitySuppressed(individual))
			return;

	if (TADE_SUPPRESSION)
		if (isHLSuppressed(individual))
			return;

	all_neighbors = i1.nearestNeighbors(individual, subpop.individualCount);
	neighbors = all_neighbors[all_neighbors.sex == "M"]; //male neighbors
	if (size(neighbors) == 0) // If no mates are in mate detection range, cannot mate.
		return;
	attempt_no = 0;
	while (1) {
		// First, select a random mate.
		mate_no = 0;
		if (size(neighbors) > 1)
			mate_no = rdunif(1, max=size(neighbors) - 1);
		selected_mate = neighbors[mate_no];
		// Determine attractiveness of mate.
		mate_attractiveness = 0.5*genotypeFitness(selected_mate);

		//inbreeding avoidance factor represents the percent decrease in attractiveness of a brother if positive
		//and a percent increase in attractiveness of a brother if negative
		if (selected_mate.pedigreeParentIDs[0] == individual.pedigreeParentIDs[0] & individual.pedigreeParentIDs[0] != -1)
			mate_attractiveness = mate_attractiveness * (1 - INBREEDING_AVOIDANCE_FACTOR);

		// Determine if this mate is chosen, based on attractiveness and his mating history
		if (MALE_MATE_CAP) {
			if ((runif(1) < mate_attractiveness) & (selected_mate.getValue("mates") < MAX_MALE_MATINGS)) {
				selected_mate.setValue("mates", selected_mate.getValue("mates") + 1); //increment his mate count
				break;  // Select this mate.
			}
		} else {
			if (runif(1) < mate_attractiveness)
				break;
		}
		// After twenty candidates fail, female gives up.
		attempt_no = attempt_no + 1;
		if (attempt_no == MAX_ATTEMPTS_TO_FIND_SUITABLE_MATE)
			return;
	} // Mate has now been selected.

	// Check to see if male somatic fitness penalty will decrease number of offspring. Fecundity effected only in offspring of D/+ males.
    mate_somatic_offspring_multiplier = 1;
    if (selected_mate.countOfMutationsOfType(m1) & selected_mate.countOfMutationsOfType(m2))
        mate_somatic_offspring_multiplier = SOMATIC_FITNESS_MUTLIPLIER_M;


	// Offspring number based on possion distrobution.
	// p for possion draw. Number of offspring varies with female genes and competition.
	p = mate_somatic_offspring_multiplier * genotypeFitness(individual) / (1 + RATE_FEMALES_SURVIVE);

	//inbreeding fecundity penalty represents a % decrease in the probability of generating offspring due to inbreeding
	if (selected_mate.pedigreeParentIDs[0] == individual.pedigreeParentIDs[0] & individual.pedigreeParentIDs[0] != -1)
		p = p * (1-INBREEDING_FECUNDITY_PENALTY);

	num_offspring = rpois(1, MAX_OFFSPRINGS_PER_FEMALE*p);

	//in RECESSIVE_MALE_STERILE_SUPPRESSION_DRIVE, males with an r2 or drive on both chromosomes are sterile
	if (RECESSIVE_MALE_STERILE_SUPPRESSION_DRIVE) {
		if (isRecessiveSterilitySuppressed(selected_mate))
			num_offspring = 0;
	}

	sex_ratio = 1 - (0.5 * (1 - X_SHRED_RATE)) / (0.5 + (0.5 * (1 - X_SHRED_RATE)));
	for (i in seqLen(num_offspring)) {
		// Add offspring to the subpopulation.
		if (X_LINKED_DRIVE & selected_mate.countOfMutationsOfType(m2))
			offspring = subpop.addCrossed(individual, selected_mate, sex_ratio);
		else
			offspring = subpop.addCrossed(individual, selected_mate);
		if (!isNULL(offspring)) {
			if (REPRISING_BOUNDARIES) {
				// Offspring placement within reprising boundaries.
				if (TWO_DIMENSIONAL) {
					do position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
					while (!individual.subpopulation.pointInBounds(position));
					offspring.setSpatialPosition(position);
				} else {
					do position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
					while (!individual.subpopulation.pointInBounds(position));
					offspring.setSpatialPosition(position);
				}
			}
			else {
				// Torroidal world offspring placement.
				if (TWO_DIMENSIONAL) {
					position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
					offspring.setSpatialPosition(p1.pointPeriodic(position));
				} else {
					position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
					offspring.setSpatialPosition(p1.pointPeriodic(position));
				}
			}
		}
	}
}


//// GENE DRIVE IMPLEMENTATION RULES THAT OCCUR IN EVERY CHILD.
1: modifyChild() {
	// If the drive is x-linked, prevent it from being inherited on Y chromosome:
	if (X_LINKED_DRIVE)
		copy_genome(ifelse(childIsFemale,parent2Genome1,parent2Genome2), child.genome2);

	if (HOMING_DRIVE) {
		// Apply effects that happen in the germline.
		// First, resistance alleles form.
		if (!MALE_ONLY_PROMOTER)
			germline(child.genome1, parent1, GERMLINE_RESISTANCE_CUT_RATE_F);
		germline(child.genome2, parent2, GERMLINE_RESISTANCE_CUT_RATE_M);
		// Next, homology directed repair allows for homing to occur.
		if (!MALE_ONLY_PROMOTER)
			hdr(child.genome1, parent1, HOMING_PHASE_CUT_RATE_F);
		hdr(child.genome2, parent2, HOMING_PHASE_CUT_RATE_M);
		// Then additional resistance alleles form.
		if (!MALE_ONLY_PROMOTER)
			germline(child.genome1, parent1, LATE_GERMLINE_RESISTANCE_CUT_RATE_F);
		germline(child.genome2, parent2, LATE_GERMLINE_RESISTANCE_CUT_RATE_M);

		// Apply effects that happen in the embryo.
		if (!MALE_ONLY_PROMOTER)
            embryo(child.genome1, child.genome2, parent1, EMBRYO_RESISTANCE_CUT_RATE_F);
        if (child.sex == F)
        	male_deposition(child.genome1, child.genome2, parent2, EMBRYO_RESISTANCE_CUT_RATE_M); 
	}

	if (TADS_MODIFICATION | TADS_AUTOSOMAL_SUPPRESSION) {
		// Apply germline resistance
		if (!MALE_ONLY_PROMOTER)
			germline(child.genome1, parent1, GERMLINE_RESISTANCE_RATE);
		germline(child.genome2, parent2, GERMLINE_RESISTANCE_RATE);

		// If the child inherited r2 from a drive heterozygous father who originally did not have r2
		if (parent2.countOfMutationsOfType(m4)==0 & parent2.countOfMutationsOfType(m2) == NUM_GRNAS) {
			while (child.genome2.countOfMutationsOfType(m4) > 0) {
				// Half the time, loop back and give the child drive instead
				if (runif(1) < 0.5)
					child.genome2.addNewDrawnMutation(m2, seqLen(NUM_GRNAS));
				else {
					// Otherwise, recreate the non-drive chromosome before germline resistance
					// and undergo germline resistance again - only exit loop if r2 doesn't result
					copy_genome(ifelse((parent2Genome1.countOfMutationsOfType(m2) == NUM_GRNAS), parent2Genome2, parent2Genome1), child.genome2);
					germline(child.genome2, parent2, GERMLINE_RESISTANCE_RATE);
				}
			}
		}

		// Fathers who were r2 heterozygotes cannot pass on an r2 allele. If this was the case, give the child the father's other allele.
		if (child.genome2.countOfMutationsOfType(m4) > 0)
			copy_genome(ifelse((parent2Genome1.countOfMutationsOfType(m4) > 0), parent2Genome2, parent2Genome1), child.genome2);

		if (!MALE_ONLY_PROMOTER)
			embryo(child.genome1, child.genome2, parent1,EMBRYO_RESISTANCE_CUT_RATE_F);
	}

	//Applicable to TADE and TARE
	if (!(HOMING_DRIVE|TADS_MODIFICATION|TADS_AUTOSOMAL_SUPPRESSION)) {
		// Apply effects that happen in the germline.
		if (!MALE_ONLY_PROMOTER)
			germline(child.genome1, parent1, GERMLINE_RESISTANCE_RATE);
		germline(child.genome2, parent2, GERMLINE_RESISTANCE_RATE);

		// Apply effects that happen in the embryo.
		if (!MALE_ONLY_PROMOTER)
			embryo(child.genome1, child.genome2, parent1,EMBRYO_RESISTANCE_CUT_RATE_F);
	}

	// If the drive is x-linked, prevent gene drive mechanics on Y chromosome by resetting it:
	if (X_LINKED_DRIVE)
		copy_genome(ifelse(childIsFemale,parent2Genome1,parent2Genome2), child.genome2);

	// Offspring may be non viable offspring if drive
	// is haplolethal or haplosufficient recesive lethal.
	// Booleans describing presence of alleles.
	num_drives = sum(child.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
	num_r2s = sum(child.genomes.countOfMutationsOfType(m4) > 0);

	//haplolethality applies in TADE and TADE Suppression drives or if programmed for homing drives
	haplolethal_one_rescue = ifelse(TADE|TADE_SUPPRESSION|HAPLOLETHAL,T,F);

	//haplosufficiency rules apply in TARE or if programmed for homing drives
	haplosufficiency = ifelse(TARE|HAPLOSUFFICIENT, T, F);

	// If drive is haplolethal:
	// Offspring not viable if it has r2 on either chromosome; one drive is not enough to rescue
	if (haplolethal_one_rescue & num_r2s > 0)
		return F;

	// If this is TADE double rescue, then the offspring is only nonviable if it obtained an r2 and does not have any drive alleles;
	// one drive is enough to rescue
	if (TADE_DOUBLE_RESCUE & num_r2s > 0 & num_drives==0)
		return F;

	// If drive is haplosufficient: offspring not viable if r2 on both chromosomes.
	if (haplosufficiency & num_r2s==2)
		return F;

	//if X-linked, male, and at least one r2, offspring dies
	if (haplosufficiency & X_LINKED_DRIVE & (child.sex == "M") & (num_r2s > 0))
		return F;

	//new: if this is a recessive lethal drive, any combination of 2 drive or r2 alleles is lethal
	if (RECESSIVE_BOTH_SEX_LETHAL_SUPPRESSION_DRIVE) {
		if ((child.genome1.countOfMutationsOfType(m2) == NUM_GRNAS | child.genome1.countOfMutationsOfType(m4) > 0) & (child.genome2.countOfMutationsOfType(m2) == NUM_GRNAS| child.genome2.countOfMutationsOfType(m4) > 0))
			return F;
	}

	if (!(child.sex == "F") & MALE_MATE_CAP)
		child.setValue("mates", 0); //track mating history of new male offspring

	return T;
}


//// COLOR RULES FOR SLIM GUI DISPLAY.
early() {
	if (!SUPPRESSION_OUTPUT) {
		all = sim.subpopulations.individuals;
		all[all.countOfMutationsOfType(m1) == 0].color = "yellow";
		all[all.countOfMutationsOfType(m1) > 0].color = "white";
		drive = all[all.countOfMutationsOfType(m2) >= NUM_GRNAS];
		drive[drive.countOfMutationsOfType(m1)==0].color = "purple";
		drive[drive.countOfMutationsOfType(m1) > 0].color = "purple";
	} else {
		all = sim.subpopulations.individuals;
		all.color = "blue"; // wt individuals are blue
		two_res = (all.genome1.countOfMutationsOfType(m4) | all.genome1.countOfMutationsOfType(m3) == NUM_GRNAS) & (all.genome2.countOfMutationsOfType(m4) | all.genome2.countOfMutationsOfType(m3) == NUM_GRNAS);

		all[two_res].color = "yellow"; //resistance homozygotes are yellow
		all[all.countOfMutationsOfType(m2) >= NUM_GRNAS].color = "red"; //drive-carrying individuals are red
	}
	// catn("=========="+DENSITY_GROWTH_CURVE);
}

//// VIABILITY COMPETITION
early() {
	i2.evaluate(sim.subpopulations);
	all = sim.subpopulations.individuals;
	newborn = all[all.age == 0];
	//catn("==========="+size(newborn));
	for (ind in newborn) {
		nn = i2.nearestNeighbors(ind,p1.individualCount,p1);
		new = nn[nn.age==0];
		competition_ratio = size(new) / EXPECTED_COMPETITION;
		actual_competition_factor = 2*GROWTH_AT_ZERO_DENSITY/MAX_OFFSPRINGS_PER_FEMALE/ ((GROWTH_AT_ZERO_DENSITY-1) * competition_ratio + 1);
		ind.fitnessScaling = actual_competition_factor;
	}

}

//// EVALUATE SPATIAL INTERACTIONS BETWEEN INDIVIDUALS FOR OTHER FUNCTIONS.
late() {
	i1.evaluate(sim.subpopulations);
	i2.evaluate(sim.subpopulations);
	catn(size(p1.individuals));
}


//// SURVIVAL RULES FOR THE SIMULATION BASED ON AGE AND RULES FOR MOVEMENT.
late() {
	all = sim.subpopulations.individuals;
	is_male = all.sex=="M";

	//by default, create non-overlapping generations
	all[is_male].fitnessScaling = 0.0;
	females = all[!is_male];
	females.fitnessScaling = 0.0;

	//user may allow some females to survive
	if (RATE_FEMALES_SURVIVE > 0.0) {
		num_survive = round(RATE_FEMALES_SURVIVE*size(females));
		fem_survive = sample(females, num_survive);
		fem_survive.fitnessScaling = 1.0;
	}

	surviving_inds = all[all.fitnessScaling > 0.0];

	//surviving individuals move
	for (ind in surviving_inds) {
		if (REPRISING_BOUNDARIES) {
			// Movement within reprising boundaries.
			if (TWO_DIMENSIONAL) {
				do position = ind.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
				while (!ind.subpopulation.pointInBounds(position));
				ind.setSpatialPosition(position);
			} else {
				do position = ind.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
				while (!ind.subpopulation.pointInBounds(position));
				ind.setSpatialPosition(position);
			}
		} else {
			// Torroidal world movement.
			if (TWO_DIMENSIONAL) {
				ind.x = ind.x + rnorm(1, 0, FEMALE_SPEED);
				ind.y = ind.y + rnorm(1, 0, FEMALE_SPEED);
				ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
			} else {
				ind.x = ind.x + rnorm(1, 0, FEMALE_SPEED);
				ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
			}
		}
	}
}
//// test wave speed
late() {
	all = sim.subpopulations.individuals;
	if(!TWO_DIMENSIONAL & NO_DROP){
			pos_vec = 0:(NUMBER_OF_CELLS-1);
			length = SIM_BOUND/NUMBER_OF_CELLS;
			allx = all.x;
			all_track = c();
			for (i in pos_vec){
				left = length*i;
				right = length*(i+1);
				all_in_division = (allx >= left) & (allx < right);
				all_in_cell = all[all_in_division];
				all_cell_count = size(all_in_cell);
				all_track = c(all_track, all_cell_count);
			}
			//catn(all_track);
			avg_ind_per_cell = round(CAPACITY/NUMBER_OF_CELLS);
			cells = pos_vec[(all_track >= 0.5*avg_ind_per_cell)];
			//catn(avg_ind_per_cell);
			if (size(cells)>=1){
				wave_pos = cells[size(cells)-1];
				catn("generation: "+sim.cycle+" wave_pos: "+wave_pos);
				if(wave_pos>=NUMBER_OF_CELLS-1)
					sim.simulationFinished();
			}
	}
}


//// START THE SIMULATION BY ADDING AN INITIAL WILD POPULATION.
1 early() {
	// Start with a population of wild-type.
	if (TWO_DIMENSIONAL){
		sim.addSubpop("p1", CAPACITY);
	}else{
		sim.addSubpop("p1", asInteger(CAPACITY*0.1/SIM_BOUND));
	}
	if (TWO_DIMENSIONAL)
		p1.setSpatialBounds(c(0.0,0.0,SIM_BOUND,SIM_BOUND));
	else
		p1.setSpatialBounds(c(0.0,SIM_BOUND));
	all = p1.individuals;

	// Add wt to the cut-chromosome

	if (TWO_DIMENSIONAL) {
		all.genomes.addNewDrawnMutation(m1, seqLen(NUM_GRNAS));
		all.x = runif(CAPACITY,min=0,max=SIM_BOUND);
		all.y = runif(CAPACITY,min=0,max=SIM_BOUND);
	} else {
		all.x = runif(asInteger(CAPACITY*0.1/SIM_BOUND),min=0,max=0.1);
		//all.x = p1.pointUniform(CAPACITY);
		sim.setValue("timer", "start");
	}

	if (MALE_MATE_CAP)
		all[all.sex=="M"].setValue("mates", 0);

	if (SUPPRESSION_OUTPUT)
		sim.setValue("track_eq", NULL);


	sim.setValue("npops", 1); // track number of subpopulations
	sim.setValue("chasing start",0);

}

//// DROP A GROUP OF MODIFIED INDIVIDUALS INTO THE POPULATION.
10: early() {
	if (NO_DROP | WT_START)
		return;

	this_gen = sim.cycle - 10; // drop is 0

	// let a RELEASE_INTERVAL of 1000 indicate that we're only releasing once
//	if (RELEASE_INTERVAL==1000 & this_gen > 0)
//		return;   ///?没有必要

	if (this_gen%RELEASE_INTERVAL!= 0)
		return; // release at the interval generations only

	id_num = sim.getValue("npops") + 1;
	sim.setValue("npops", id_num);

	// Add a drop of modified individuals to p1.
	if (MALE_ONLY_DROP)
		// Drop a population of only males.
		sim.addSubpop(id_num, DROP_SIZE, 1.0);
	else if (FEMALE_ONLY_DROP)
		// Drop a population of only females.
		sim.addSubpop(id_num, DROP_SIZE, 0.0);
	else
		sim.addSubpop(id_num, DROP_SIZE);

	// Eidos is zero-based
	drop = sim.subpopulations[id_num-1].individuals;

	// Now set the drop individuals to the correct genotypes:
	drop.genomes.addNewDrawnMutation(m2, seqLen(NUM_GRNAS));

	// For heterozygous drop, one of the chromosomes is set to wild type:
	if (HETEROZYGOUS_DROP)
		drop.genome2.addNewDrawnMutation(m1, seqLen(NUM_GRNAS));

	// In X_LINKED_DRIVE males' genome2 (from father) is always wt.
	if (X_LINKED_DRIVE)
		drop[drop.sex == "M"].genome2.addNewDrawnMutation(m1, seqLen(NUM_GRNAS));

	// Move all the individuals from the drop into p1:
	p1.takeMigrants(drop);


	if (TWO_DIMENSIONAL) {
		if (LEFT_EDGE_DROP) { //left-rectangle drop
			drop.x = runif(DROP_SIZE, 0, DROP_RADIUS);
			drop.y = runif(DROP_SIZE);
		} else if (CIRCLE_DROP) { //default circle drop
			drop.x = 0.5*SIM_BOUND + rnorm(DROP_SIZE, 0, DROP_RADIUS);
			drop.y = 0.5*SIM_BOUND + rnorm(DROP_SIZE, 0, DROP_RADIUS);
		} else if (UNIFORM_DROP) { //scattered uniformly
			drop.x = runif(DROP_SIZE);
			drop.y = runif(DROP_SIZE);
		} else if (CORNER_DROP) {
			for (ind in drop) {
				ind.x = rnorm(1, 0, DROP_RADIUS);
				ind.y = rnorm(1, 0, DROP_RADIUS);
				ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
			}
		}
	} else {
		//only left-edge drops are possible for 1D
		drop.x = runif(DROP_SIZE, 0, DROP_RADIUS);
	}

	if (MALE_MATE_CAP)
		drop[drop.sex=="M"].setValue("mates", 0); //track males' mates

	if (TRACK_BY_CELL)
		sim.setValue("start_gc_tracking", F); //don't start until number of wt alleles falls below 80% eq
}

//// PROGRAM OUTPUT AFTER DROP.
10: late() {

	if (WT_START)
		return;

	// population
	all = p1.individuals;
	this_gen = sim.cycle-10;
	pop_size = length(all);
	males = all[all.sex=="M"];
	num_males = length(males);
	females = all[all.sex=="F"];
	num_females = length(females);
	num_fertile_females = sum(females.countOfMutationsOfType(m1)>0 | females.countOfMutationsOfType(m3)>0);
	catn("FERTILE_FEMALES:: "+num_fertile_females);
	catn("FEMALES:: "+num_females);
	catn("MALES:: "+num_males);

	//count of chromosomes
	num_y = num_males;
	num_x = 2*num_females + num_males;
	num_autosomal_chromosomes = 2*pop_size;

	//allele counts
	num_wt = sum(all.genomes.countOfMutationsOfType(m1)==NUM_GRNAS);
	num_dr = sum(all.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
	num_complete_r1 = sum(all.genomes.countOfMutationsOfType(m3)==NUM_GRNAS);
	num_r2 = sum(all.genomes.countOfMutationsOfType(m4)>0);
	num_has_drive = sum(all.countOfMutationsOfType(m2) >= NUM_GRNAS);
	num_nondrive = pop_size - num_has_drive;
	rate_has_drive = num_has_drive/pop_size;

	num_wt_homoz = sum(all.countOfMutationsOfType(m1)==2*NUM_GRNAS);
	rate_wt_homoz = num_wt_homoz/pop_size;

	//rate calculations may differ
	if (!X_LINKED_DRIVE) {
		rate_dr = num_dr/num_autosomal_chromosomes;
		rate_wt = num_wt/num_autosomal_chromosomes;
		rate_complete_r1 = num_complete_r1/num_autosomal_chromosomes;
		rate_r2 = num_r2/num_autosomal_chromosomes;
	} else {
		rate_dr = num_dr/num_x;
		rate_wt = num_wt/num_x;
		rate_complete_r1 = num_complete_r1/num_x;
		rate_r2 = num_r2/num_x;
	}

	//CHASING ANALYSIS
	if (SUPPRESSION_OUTPUT) {

		//first check for a chase
		if (num_wt < EQUILIBRIUM_WT_ALLELE_THRESHOLD) {
			catn("POTENTIAL_CHASE:: " + this_gen);
			if (TRACK_BY_CELL) {
				if (!sim.getValue("start_gc_tracking"))
					sim.setValue("start_gc_tracking", T); //now start tracking by cell
			}
		}

		//2D-specific output
		if (TWO_DIMENSIONAL) {
			//output for python
			if (NO_DROP)
				sim.setValue("start_gc_tracking", T); //start tracking GC
			else {
				catn("GEN: "+this_gen+" RATE_DR: " + rate_dr);
				if (!TRACK_BY_CELL)
					catn("WT_ALLELES:: " + num_wt + " " + this_gen + " " + pop_size);
			}

			//record quadrant counts and calculate greens coefficient for chasing
			//detection and overall
			if (TRACK_BY_CELL)  {
				//only start recording once the number of WT alleles first falls below 80% of equilibrium
				if (sim.getValue("start_gc_tracking")) {

					nondrive = all[all.countOfMutationsOfType(m2) == 0]; //obtain non-drive individuals
					nonx = nondrive.x;
					nony = nondrive.y;
					allx = all.x; //also track overall green's coefficient
					ally = all.y;
					pos_vec = 0:(sqrt(NUMBER_OF_CELLS) - 1);
					dim = length(pos_vec);
					cell_width = SIM_BOUND/dim;
					positions = pos_vec * cell_width; //iterate through these x and y positions
					nondrive_track = c(); //used for chasing detection
					all_track = c();

					for (i in 0:(dim-1)) {
						div_left = positions[i];
						for (j in 0:(dim-1)) {
							div_bot = positions[j];

							nondrive_in_division = (nonx >= div_left) & (nonx < (div_left + cell_width)) & (nony >= div_bot) & (nony < (div_bot + cell_width));
							nondrive_in_cell = nondrive[nondrive_in_division];
							nondrive_cell_count = size(nondrive_in_cell); //number in this cell
							nondrive_track = c(nondrive_track, nondrive_cell_count); //add this onto this generation's count tracker

							all_in_division = (allx >= div_left) & (allx < (div_left + cell_width)) & (ally >= div_bot) & (ally < (div_bot + cell_width));
							all_in_cell = all[all_in_division];
							all_cell_count = size(all_in_cell);
							all_track = c(all_track, all_cell_count);
						}
					} //done obtaining cell counts

					//add the pop_size of all cells in this generation to varibles
					chasing_start = sim.getValue("chasing start");
					if (T){//chasing_start ==0
						chasing_cell = 0;
						index = integerMod(sim.cycle + 2,6);
						compare_index = integerMod(sim.cycle + 3,6);
						start = compare_index*NUMBER_OF_CELLS;
						end = (compare_index+1)*NUMBER_OF_CELLS-1;
						start1 = index*NUMBER_OF_CELLS;
						end1 = (index+1)*NUMBER_OF_CELLS-1;
						before = cell_pop_size[start:end];
						before_pop_size = time_pop_size[compare_index];
						time_pop_size[index] = pop_size;
						defineGlobal("time_pop_size",time_pop_size);
						cell_pop_size[start1:end1] = all_track;
						defineGlobal("cell_pop_size",cell_pop_size);
						/*start = integerMod((compare_index)*NUMBER_OF_CELLS,(6*NUMBER_OF_CELLS));
						end = integerMod((compare_index+1)*NUMBER_OF_CELLS-1,(6*NUMBER_OF_CELLS));*/
						before = cell_pop_size[start:end];
						//before_pop_size = time_pop_size[(compare_index)%6];
						chasing_cell_no = c();
						if (before[0] != -1){
							//compare 5 generations later and before
							cell_no = 0:(NUMBER_OF_CELLS-1);
							for (i in cell_no){
								if (before[i]==0 & pop_size!=0){ //<=0.01*before_pop_size/NUMBER_OF_CELLS
									//print("======="+all_track[i]);
									if (nondrive_track[i] >= num_nondrive/NUMBER_OF_CELLS & num_nondrive>=0.1*pop_size){
										chasing_cell = chasing_cell + 1;
										chasing_cell_no = c(chasing_cell_no,i);
									}
								}
							}
							cat("chasing cells: ");
							catn(chasing_cell_no);
							defineGlobal("chasing_cells",chasing_cell_no);
							if (chasing_start==0 & chasing_cell>=3)
								sim.setValue("chasing start" , this_gen);
						}
					}
					
					// to compute the nearest neighbor index for all seted points
					i3.evaluate(sim.subpopulations);

					// to compute the nearest neighbor index of all individuals
					nni_list = c();
					for (ind in all){
						nn = i3.nearestInteractingNeighbors(ind,count=1);
						dis = i3.distance(ind,nn);
						nni_list = c(nni_list,dis);
					}
					if (!isNULL(nni_list) & pop_size>1){
						ave_of_nni = mean(nni_list);
						var_of_nni = var(nni_list);
					}
					else {
						ave_of_nni = 0;
						var_of_nni = 0;
					}
					
					//Green's Coefficient is a measure of clustering for this generation
					//when individuals are completely randomly distributed, GC = 0.
					//when individuals are as clustered as possible, GC = 1.

					nondrive_pop_size = sum(nondrive_track);

					//prevent nan errors
					if (T) { //nondrive_pop_size > 1 todo
						nondrive_greens_coeff = (var(nondrive_track)/mean(nondrive_track) - 1)/(sum(nondrive_track) - 1);
						all_greens_coeff = (var(all_track)/mean(all_track) - 1)/(sum(all_track)-1);
						// (1) number wt alleles (2) gen (3) population size (5) gc for chase detection (7) overall gc
						catn("WT_ALLELES:: " + num_wt + " " + this_gen + " " + pop_size + " "+rate_has_drive+" AVERAGE_NNI:: "+ave_of_nni+" VARIANCE_NNI:: "+var_of_nni);
					}
				}
			}
		} 

		if (NO_DROP){
			if (p1.individualCount == 0){
				sim.simulationFinished();
			}
			return;
		}
		//// conditions that may stop the simulation for SUPPRESSION drives:

		chasing_start = sim.getValue("chasing start");
		//1-drive was lost and wt population remained
		if (num_dr == 0 & pop_size>0) {
			if(isNULL(sim.getValue("pop_persists"))){
				sim.setValue("pop_persists", this_gen);
			}
		}
		end = sim.getValue("pop_persists");
		if(!isNULL(end)){
		 	if(this_gen-end>10){
		 		catn("POP_PERSISTS:: " + end);
		 		if (chasing_start!=0)
		 			catn("CHASING START:: "+chasing_start);
				sim.simulationFinished();
		 	}
		}
		
		//print("chasing_start:  "+chasing_start);
		//3-suppression occurs
		if (pop_size == 0 & chasing_start==0){
			catn("SUPPRESSED WITHOUT CHASING:: " + this_gen);
			sim.simulationFinished();
		}

		if (pop_size == 0 & chasing_start!=0){
			catn("SUPPRESSED WITH CHASING:: " + this_gen);
			catn("CHASING START:: "+chasing_start);
			sim.simulationFinished();
		}

		if (RELEASE_INTERVAL!=1000 & rate_wt_homoz == 0) {
			catn("SUPPRESSED:: " + this_gen);
			sim.simulationFinished();
		}
		
		// catn("CHASING START:: "+chasing_start);
	}
}

//if no drop, stop after 100 generations of tracking
110 late() {
	if (!NO_DROP)
		return;
	sim.simulationFinished();
}

////output 1000 generations after drop if simulation hasn't ended already
// 375 equal to 1000 time steps in 6 age model.
385 late() {

	if (WT_START)
		return;

	all = p1.individuals;
	has_drive = sum(all.countOfMutationsOfType(m2) >= NUM_GRNAS);
	rate_has_drive = has_drive/size(all);

	catn("ENDING_AFTER_375:: " + rate_has_drive); //show the rate of individuals with drive
	catn("CHASING START:: "+sim.getValue("chasing start"));	
	sim.simulationFinished();
}


500 late() {
	if (WT_START)
		catn("ENDING_AFTER_500::");
}

//// SET OUTPUT PATH FOR VISUALIZATION  FUNCTION:
1 early() {
    if (OUTPUT_SPATIAL_DATA) {
        //defineConstant("OUTPUT_PATH", getwd() + "/0-0results/" +"slim_g"+WHOLE_GERMLINE_RESISTANCE_CUT_RATE+ 'c'+DRIVE_CONVERSION +'f'+SOMATIC_FITNESS_MULTIPLIER_F+'e'+EMBRYO_RESISTANCE_CUT_RATE_F_INPUT+"_movie");
		defineConstant("OUTPUT_PATH", getwd() +"/"+OUTPUT_FILE);
        deleteFile(OUTPUT_PATH);
        //catn("======="+getwd()+"======");
    }
}
//// VISUALIZATION FUNCTION:
late() {
    if (OUTPUT_SPATIAL_DATA) {
        all = sim.subpopulations.individuals;
        output_str = "G";
        for (ind in all) {
            if (ind.color == "")
                ind.color = "blue";
            ind_colors = color2rgb(ind.color);
            hex_x = format("%.3x ", asInteger(ind.x * 4095 + 0.5));
            hex_y = format("%.3x ", asInteger(ind.y * 4095 + 0.5));
            hex_r = format("%.2x ", asInteger(255 * ind_colors[0]));
            hex_g = format("%.2x ", asInteger(255 * ind_colors[1]));
            hex_b = format("%.2x",  asInteger(255 * ind_colors[2]));
            output_str = output_str + "\n" +  hex_x + hex_y + hex_r + hex_g + hex_b;
        }
        writeFile(OUTPUT_PATH, output_str, T);
    }
}